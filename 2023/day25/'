use std::collections::{HashMap, VecDeque};
use std::cmp::min;

#[allow(dead_code)]
const INPUT: &'static str = "\
jqt: rhn xhk nvd
rsh: frs pzl lsr
xhk: hfx
cmg: qnr nvd lhk bvb
rhn: xhk bvb hfx
bvb: xhk hfx
pzl: lsr hfx nvd
qnr: nvd
ntq: jqt hfx bvb xhk
nvd: lhk
lsr: lhk
rzs: qnr cmg lsr rsh
frs: qnr lhk lsr";

#[allow(dead_code)]
const EXPECTED: &'static str = "54";


fn main() {
    let input = include_str!("../input.txt");
    let sol = solution(input);
    dbg!(sol);
}

// Implementation of Edmonds Karp to determine the maximum flow / minimum cut
fn bfs(graph: &Vec<Vec<usize>>, visited: &mut Vec<usize>, capacity: &mut Vec<Vec<i64>>, flow: &mut Vec<Vec<i64>>, residual_flow: &mut Vec<Vec<i64>>, source: usize, sink: usize, visited_token: usize) -> i64 {
    println!("{capacity:?}");
    let mut q = VecDeque::with_capacity(graph.len());
    q.push_back(source);
    // Store previous node to recreate the path
    let mut prev = vec![None; graph.len()];
    while let Some(node) = q.pop_front() {
        if node == sink {
            break;
        }
        for &neighbor in graph[node].iter() {
            let cap = capacity[node][neighbor] - flow[node][neighbor];
            if cap > 0 && visited[neighbor] != visited_token {
                visited[neighbor] = visited_token;
                prev[neighbor] = Some(node);
                q.push_back(neighbor);
            }
        }
    }
    let mut ss = String::new();
    let mut curr = sink;
    ss.push_str(sink.to_string().as_str());
    while let Some(prev_node) = prev[curr] {
        ss.push_str(" -> ");
        ss.push_str(prev_node.to_string().as_str());
        curr = prev_node;
    }
    println!("{ss}");

    // Unreachable sink
    if prev[sink].is_none() {
        return 0;
    }
    let mut bottle_neck = i64::MAX;
    let mut curr = sink;
    while let Some(prev_node) = prev[curr] {
        bottle_neck = min(bottle_neck, capacity[curr][prev_node] - flow[curr][prev_node]);
        curr = prev_node;
    }
    while let Some(prev_node) = prev[curr] {
        flow[curr][prev_node] += bottle_neck;
        residual_flow[curr][prev_node] -= bottle_neck;
        curr = prev_node;
    }
    println!("bottle neck: {bottle_neck}");
    return bottle_neck;
}

fn solution(s: &str) -> String {
    let mut node_map: HashMap<&str, usize> = HashMap::new();
    let graph: Vec<Vec<usize>> = s.lines().fold(Vec::new(), |mut acc, line| {
        // Map all nodes to a number for adjacency matrices
        let mut parts = line.split(": ");
        let left = parts.next().unwrap();
        let left_id: usize;
        if let Some(&id) = node_map.get(left) {
            left_id = id;
        } else {
            left_id = node_map.len();
            node_map.insert(left, left_id);
            acc.push(Vec::new());
        }
        let right: Vec<_> = parts.next().unwrap().split_whitespace().map(|node| {
            let node_id: usize;
            if let Some(&id) = node_map.get(node) {
                node_id = id;
            } else {
                node_id = node_map.len();
                node_map.insert(node, node_id);
                acc.push(Vec::new());
            }
            node_id
        }).collect();
        for right_id in right {
            acc[right_id].push(left_id);
            acc[left_id].push(right_id);
        }
        acc
    });

    let num_nodes = graph.len();
    let mut visited_token = 0;  // Can increment to mark nodes as unvisited in current iteration.
    let mut visited: Vec<usize> = vec![visited_token; graph.len()];

    let source_node = 0;
    for sink_node in 1..graph.len() {
        let mut max_flow = 0i64;
        let mut flow = -1i64;

        let mut flow_matrix = vec![vec![0; num_nodes]; num_nodes];
        let mut residual_flow_matrix = vec![vec![0; num_nodes]; num_nodes];
        let mut capacity_matrix = vec![vec![0; num_nodes]; num_nodes];
        for (node_id, neighbors) in graph.iter().enumerate() {
            for &neighbor in neighbors {
                capacity_matrix[node_id][neighbor] = 1;
            }
        }
        while flow != 0 {
            visited_token += 1;
            flow = bfs(&graph, &mut visited, &mut capacity_matrix, &mut flow_matrix, &mut residual_flow_matrix, source_node, sink_node, visited_token);
            max_flow += flow;
        }
        println!("Max flow: {max_flow}");
    }

    let ans = 0;
    println!("{ans}");
    return ans.to_string();
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_solution() {
        assert!(solution(INPUT) == EXPECTED.to_string());
    }
}
